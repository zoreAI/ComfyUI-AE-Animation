<script setup lang="ts">
import { ref, computed, reactive, onMounted, onBeforeUnmount, watch } from 'vue'
import { useTimelineStore } from '@/stores/timelineStore'
import CanvasPreview from '@/components/timeline/CanvasPreview.vue'

const BASE_PIXELS_PER_SECOND = 60

const props = defineProps<{ node: any }>()
const store = useTimelineStore()
const canvasPreviewRef = ref<InstanceType<typeof CanvasPreview> | null>(null)
const fileInput = ref<HTMLInputElement>()
const projectInput = ref<HTMLInputElement>()
const timelineRef = ref<HTMLDivElement>()
const containerWidth = ref(0)
let pendingType: 'foreground' | 'background' = 'foreground'
let isDraggingRuler = false
let resizeObserver: ResizeObserver | null = null

const getWidget = (name: string) => props.node?.widgets?.find((x: any) => x.name === name)
function toNumber(value: any, fallback: number) {
  const num = typeof value === 'number' ? value : parseFloat(value)
  return Number.isFinite(num) ? num : fallback
}

const fitMode = ref<'fit' | 'fill' | 'stretch'>('fit')

const projectDuration = computed(() => {
  const fps = Math.max(1, store.project.fps || 1)
  return store.project.duration || (store.project.total_frames / fps) || 0
})

const pixelsPerSecond = computed(() => {
  const duration = Math.max(0.001, projectDuration.value || 0)
  const width = containerWidth.value || timelineRef.value?.clientWidth || 0
  const fit = width ? width / duration : BASE_PIXELS_PER_SECOND
  return Math.max(BASE_PIXELS_PER_SECOND, fit)
})

watch(() => store.extractMode.enabled, (enabled) => {
  if (!enabled) {
    canvasPreviewRef.value?.clearExtractSelection?.()
  }
})

function syncTimelineWidth() {
  if (!timelineRef.value) return
  const parentWidth = timelineRef.value.parentElement?.clientWidth || timelineRef.value.getBoundingClientRect().width || 0
  const viewportWidth = typeof window !== 'undefined' ? window.innerWidth : parentWidth
  containerWidth.value = Math.min(parentWidth || viewportWidth, viewportWidth)
}

onMounted(() => {
  loadFromNodeWidgets()
  syncTimelineWidth()
  if (typeof ResizeObserver !== 'undefined' && timelineRef.value) {
    resizeObserver = new ResizeObserver((entries) => {
      const entry = entries[0]
      if (entry?.contentRect) {
        containerWidth.value = entry.contentRect.width
      }
    })
    resizeObserver.observe(timelineRef.value)
  } else {
    window.addEventListener('resize', syncTimelineWidth)
  }
})

let isDraggingKeyframe = false
let draggingKeyframeData: { layerIdx: number, prop: string, originalTime: number } | null = null

const expandedLayersSet = new Set<number>([0])
const expandedLayers = ref<Set<number>>(expandedLayersSet)
const selectedKeyframe = ref<{ layerIdx: number, prop: string, time: number } | null>(null)

function isLayerExpandedSafe(layerIdx: number): boolean {
  try {
    const set = expandedLayers.value
    return set ? set.has(layerIdx) : expandedLayersSet.has(layerIdx)
  } catch {
    return expandedLayersSet.has(layerIdx)
  }
}

const animatableProps = [
  { key: 'x', label: 'X' },
  { key: 'y', label: 'Y' },
  { key: 'scale', label: 'Scl' },
  { key: 'rotation', label: 'Rot' },
  { key: 'opacity', label: 'Op' }
]

const currentLayerProps = computed(() => {
  const layer = store.currentLayer
  if (!layer) return { x: 0, y: 0, scale: 1, rotation: 0, opacity: 1 }
  const time = store.currentTime
  const interpolate = (prop: string, defaultVal: number) => {
    if (!layer.keyframes?.[prop] || layer.keyframes[prop].length === 0) return layer[prop] ?? defaultVal
    const kfs = layer.keyframes[prop]
    if (kfs.length === 1) return kfs[0].value
    let before = kfs[0]
    let after = kfs[kfs.length - 1]
    for (let i = 0; i < kfs.length - 1; i++) {
      if (kfs[i].time <= time && kfs[i + 1].time >= time) {
        before = kfs[i]
        after = kfs[i + 1]
        break
      }
    }
    if (time <= before.time) return before.value
    if (time >= after.time) return after.value
    const t = (time - before.time) / (after.time - before.time)
    return before.value + (after.value - before.value) * t
  }
  return {
    x: interpolate('x', 0),
    y: interpolate('y', 0),
    scale: interpolate('scale', 1),
    rotation: interpolate('rotation', 0),
    opacity: interpolate('opacity', 1)
  }
})

function updateProp(prop: string, event: Event) {
  const layer = store.currentLayer
  if (!layer) return
  const value = parseFloat((event.target as HTMLInputElement).value)
  if (isNaN(value)) return
  const time = store.currentTime
  if (layer.keyframes && layer.keyframes[prop] && layer.keyframes[prop].length > 0) {
    const kfIndex = layer.keyframes[prop].findIndex((k: any) => Math.abs(k.time - time) < 0.05)
    if (kfIndex >= 0) {
      layer.keyframes[prop][kfIndex] = { time: layer.keyframes[prop][kfIndex].time, value }
    } else {
      layer.keyframes[prop].push({ time, value })
      layer.keyframes[prop].sort((a: any, b: any) => a.time - b.time)
    }
  }
  store.updateLayer(store.currentLayerIndex, { [prop]: value })
}

function formatTime(seconds: number): string {
  const mins = Math.floor(seconds / 60)
  const secs = Math.floor(seconds % 60)
  const frames = Math.floor((seconds % 1) * store.project.fps)
  return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${frames.toString().padStart(2, '0')}`
}

function getPropertyKeyframes(layer: any, prop: string) {
  if (!layer.keyframes || !layer.keyframes[prop]) return []
  return layer.keyframes[prop].map((kf: any) => ({ time: kf.time, value: kf.value }))
}

function formatValue(value: number, prop: string): string {
  if (prop === 'opacity') return (value * 100).toFixed(0) + '%'
  return value.toFixed(1)
}

function toggleLayerExpand(layerIdx: number) {
  const set = expandedLayers.value || expandedLayersSet
  if (set.has(layerIdx)) {
    set.delete(layerIdx)
  } else {
    set.add(layerIdx)
  }
  if (!expandedLayers.value) {
    expandedLayers.value = set
  }
}

function toggleVis(layer: any) {
  console.log('Toggle vis', layer.id)
}

function getTimeFromEvent(e: MouseEvent): number {
  if (!timelineRef.value) return 0
  const rect = timelineRef.value.getBoundingClientRect()
  const scrollLeft = timelineRef.value.scrollLeft
  const clickX = e.clientX - rect.left + scrollLeft
  const pps = pixelsPerSecond.value || BASE_PIXELS_PER_SECOND
  if (clickX <= 10) return 0
  const time = clickX / pps
  return Math.max(0, Math.min(time, projectDuration.value))
}

function onRulerMouseDown(e: MouseEvent) {
  e.preventDefault()
  isDraggingRuler = true
  store.setCurrentTime(getTimeFromEvent(e))
  const onGlobalMove = (moveE: MouseEvent) => {
    if (!isDraggingRuler) return
    store.setCurrentTime(getTimeFromEvent(moveE))
  }
  const onGlobalUp = () => {
    isDraggingRuler = false
    document.removeEventListener('mousemove', onGlobalMove)
    document.removeEventListener('mouseup', onGlobalUp)
  }
  document.addEventListener('mousemove', onGlobalMove)
  document.addEventListener('mouseup', onGlobalUp)
}

function onRulerMouseMove(e: MouseEvent) {
  if (!isDraggingRuler) return
  store.setCurrentTime(getTimeFromEvent(e))
}

function onRulerMouseUp() {
  isDraggingRuler = false
}

function onTrackDblClick(e: MouseEvent) {
  if (!store.currentLayer) return
  const time = getTimeFromEvent(e)
  store.setCurrentTime(time)
  store.addKeyframe()
}

function addKeyframeAt(e: MouseEvent, layerIdx: number, prop: string) {
  const target = e.currentTarget as HTMLElement
  const rect = target.getBoundingClientRect()
  const localX = e.clientX - rect.left
  const pps = pixelsPerSecond.value || BASE_PIXELS_PER_SECOND
  const time = Math.max(0, localX / pps)
  const layer = store.layers[layerIdx]
  if (!layer) return
  const value = layer[prop] ?? (prop === 'scale' || prop === 'opacity' ? 1 : 0)
  if (!layer.keyframes) layer.keyframes = {}
  if (!layer.keyframes[prop]) layer.keyframes[prop] = []
  const existing = layer.keyframes[prop].find((kf: any) => Math.abs(kf.time - time) < 0.05)
  if (!existing) {
    layer.keyframes[prop].push({ time, value })
    layer.keyframes[prop].sort((a: any, b: any) => a.time - b.time)
  }
}

function selectKeyframe(layerIdx: number, prop: string, time: number) {
  selectedKeyframe.value = { layerIdx, prop, time }
  store.selectLayer(layerIdx)
  store.setCurrentTime(time)
}

function isKeyframeSelected(layerIdx: number, prop: string, time: number): boolean {
  const sel = selectedKeyframe.value
  if (!sel) return false
  return sel.layerIdx === layerIdx && sel.prop === prop && Math.abs(sel.time - time) < 0.01
}

function onKeyframeDragStart(e: MouseEvent, layerIdx: number, prop: string, kf: any) {
  e.preventDefault()
  isDraggingKeyframe = true
  draggingKeyframeData = { layerIdx, prop, originalTime: kf.time }
  selectKeyframe(layerIdx, prop, kf.time)
  const startX = e.clientX
  const startTime = kf.time
  const pps = pixelsPerSecond.value || BASE_PIXELS_PER_SECOND
  const onMove = (moveE: MouseEvent) => {
    if (!isDraggingKeyframe || !draggingKeyframeData) return
    const diffX = moveE.clientX - startX
    const diffTime = diffX / pps
    let newTime = Math.max(0, startTime + diffTime)
    const layer = store.layers[draggingKeyframeData.layerIdx]
    if (layer?.keyframes?.[draggingKeyframeData.prop]) {
      const kfArr = layer.keyframes[draggingKeyframeData.prop]
      const kfIdx = kfArr.findIndex((k: any) => Math.abs(k.time - draggingKeyframeData!.originalTime) < 0.01)
      if (kfIdx >= 0) {
        kfArr[kfIdx].time = newTime
        draggingKeyframeData.originalTime = newTime
        selectedKeyframe.value!.time = newTime
        store.setCurrentTime(newTime)
      }
    }
  }
  const onUp = () => {
    isDraggingKeyframe = false
    draggingKeyframeData = null
    document.removeEventListener('mousemove', onMove)
    document.removeEventListener('mouseup', onUp)
    const layer = store.layers[layerIdx]
    if (layer?.keyframes?.[prop]) {
        layer.keyframes[prop].sort((a: any, b: any) => a.time - b.time)
    }
  }
  document.addEventListener('mousemove', onMove)
  document.addEventListener('mouseup', onUp)
}

function deleteKeyframe(layerIdx: number, prop: string, time: number) {
  const layer = store.layers[layerIdx]
  if (!layer?.keyframes?.[prop]) return
  layer.keyframes[prop] = layer.keyframes[prop].filter((kf: any) => Math.abs(kf.time - time) > 0.01)
  if (selectedKeyframe.value?.layerIdx === layerIdx && 
      selectedKeyframe.value?.prop === prop && 
      Math.abs(selectedKeyframe.value?.time - time) < 0.01) {
    selectedKeyframe.value = null
  }
}

function onTracksScroll(e: Event) {
  const target = e.target as HTMLElement
  const sidebar = document.querySelector('.sidebar') as HTMLElement
  if (sidebar) sidebar.scrollTop = target.scrollTop
}

function loadFromNodeWidgets() {
  if (!props.node?.widgets) return
  const width = toNumber(getWidget('width')?.value, store.project.width)
  const height = toNumber(getWidget('height')?.value, store.project.height)
  const fps = Math.max(1, toNumber(getWidget('fps')?.value, store.project.fps))
  const totalFrames = Math.max(1, Math.round(toNumber(getWidget('total_frames')?.value, store.project.total_frames)))
  const maskExpansion = toNumber(getWidget('mask_expansion')?.value, store.project.mask_expansion)
  const maskFeather = toNumber(getWidget('mask_feather')?.value, store.project.mask_feather)
  let layers: any[] = []
  const rawLayers = getWidget('layers_keyframes')?.value
  if (typeof rawLayers === 'string' && rawLayers.trim()) {
    try {
      const parsed = JSON.parse(rawLayers)
      if (Array.isArray(parsed)) layers = parsed
    } catch (err) {
      console.warn('[AE Timeline] Failed to parse layers_keyframes widget', err)
    }
  } else if (Array.isArray(rawLayers)) {
    layers = rawLayers
  }
  const projectData = {
    width, height, fps, total_frames: totalFrames,
    duration: totalFrames / fps, mask_expansion: maskExpansion, mask_feather: maskFeather
  }
  store.loadAnimation({ project: projectData, layers })
  if (store.layers.length > 0 && store.currentLayerIndex < 0) {
    store.selectLayer(0)
  }
}

function displayLayerName(layer: any, index: number) {
  if (layer.type === 'background') return 'BG'
  return `Layer ${index + 1}`
}

function exportProject() {
  const data = store.exportAnimation()
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' })
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = `ae_project_${Date.now()}.json`
  a.click()
  URL.revokeObjectURL(url)
}

function triggerLoadProject() {
  projectInput.value?.click()
}

function onLoadProject(e: Event) {
  const file = (e.target as HTMLInputElement).files?.[0]
  if (!file) return
  const reader = new FileReader()
  reader.onload = (ev) => {
    try {
      const json = JSON.parse(ev.target?.result as string)
      store.loadAnimation(json)
      console.log('Project loaded successfully')
    } catch (err) {
      console.error('Failed to parse project file', err)
      alert('工程文件损坏或格式错误')
    }
  }
  reader.readAsText(file)
  if (projectInput.value) projectInput.value.value = ''
}

function save() {
  if (!props.node?.widgets) {
    console.error('[AE Timeline] Node or widgets not found!')
    return
  }
  const findWidget = (n: string) => props.node.widgets.find((x: any) => x.name === n)
  console.log('[AE Timeline] Saving...')
  store.layers.forEach(layer => {
    if (layer.maskCanvas) {
      layer.customMask = layer.maskCanvas.toDataURL()
    }
  })
  const anim = store.exportAnimation()
  const lw = findWidget('layers_keyframes')
  if (lw) {
      const jsonStr = JSON.stringify(anim.layers)
      lw.value = jsonStr
      if (lw.inputEl) {
          lw.inputEl.value = jsonStr
          lw.inputEl.dispatchEvent(new Event("input"))
      }
      if (lw.callback) lw.callback(jsonStr)
      if (props.node.widgets_values) {
          const widgetIndex = props.node.widgets.indexOf(lw)
          if (widgetIndex >= 0) props.node.widgets_values[widgetIndex] = jsonStr
      }
      props.node.setDirtyCanvas?.(true, false)
  }
  const ww = findWidget('width')
  if (ww) {
    ww.value = store.project.width
    if (ww.inputEl) {
      ww.inputEl.value = store.project.width
      ww.inputEl.dispatchEvent(new Event("input"))
    }
    if (ww.callback) ww.callback(store.project.width)
  }
  const hw = findWidget('height')
  if (hw) {
    hw.value = store.project.height
    if (hw.inputEl) {
      hw.inputEl.value = store.project.height
      hw.inputEl.dispatchEvent(new Event("input"))
    }
    if (hw.callback) hw.callback(store.project.height)
  }
  const fw = findWidget('fps')
  if (fw) {
    fw.value = store.project.fps
    if (fw.inputEl) {
      fw.inputEl.value = store.project.fps
      fw.inputEl.dispatchEvent(new Event("input"))
    }
    if (fw.callback) fw.callback(store.project.fps)
  }
  const tw = findWidget('total_frames')
  if (tw) {
    tw.value = store.project.total_frames
    if (tw.inputEl) {
      tw.inputEl.value = store.project.total_frames
      tw.inputEl.dispatchEvent(new Event("input"))
    }
    if (tw.callback) tw.callback(store.project.total_frames)
  }
  props.node.setDirtyCanvas?.(true, false)
}

function close() {
  save()
  const dialog = document.querySelector('.ae-timeline-dialog') as HTMLDialogElement
  if (dialog) dialog.close()
}

function addKeyframe() { store.addKeyframe() }
function deleteCurrentKeyframe() { store.deleteKeyframe() }
function seekToZero() { store.setCurrentTime(0) }

function clearAllKeyframes() {
  if (!store.currentLayer) return
  if (!confirm('纭瀹瑕娓ゆ抽甯у锛')) return
  const layer = store.currentLayer
  const props: (keyof typeof layer)[] = ['x', 'y', 'scale', 'rotation', 'opacity', 'mask_size']
  props.forEach(prop => {
    if (layer.keyframes?.[prop]) {
      layer.keyframes[prop] = []
    }
  })
}

function clearCache() {
  store.layers.forEach((layer, idx) => {
    if (idx !== store.currentLayerIndex && layer.image_data) {
      console.log(`[AE Timeline] Clearing cache for layer ${layer.id}`)
    }
  })
}

function refreshPreview() {
  canvasPreviewRef.value?.scheduleRender?.()
  console.log('[AE Timeline] Preview refreshed')
}

function runNode() {
  if (props.node) {
    const graph = props.node.graph
    if (graph && (window as any).app) {
      (window as any).app.queuePrompt?.(0)
    }
  }
}

function toggleMask() {
  const next = !store.maskMode.enabled
  store.maskMode.enabled = next
  if (next) {
    store.pathMode.enabled = false
    if (store.extractMode.enabled) {
      store.extractMode.enabled = false
      canvasPreviewRef.value?.clearExtractSelection?.()
    }
  }
}

function togglePath() {
  const next = !store.pathMode.enabled
  store.pathMode.enabled = next
  if (next) {
    store.maskMode.enabled = false
    if (store.extractMode.enabled) {
      store.extractMode.enabled = false
      canvasPreviewRef.value?.clearExtractSelection?.()
    }
  }
}

function toggleExtract() {
  const next = !store.extractMode.enabled
  if (next) {
    const bgLayer = store.layers.find(l => l.type === 'background')
    if (!bgLayer) {
      alert('请先添加背景图层再使用提取功能')
      return
    }
    store.maskMode.enabled = false
    store.pathMode.enabled = false
  } else {
    canvasPreviewRef.value?.clearExtractSelection?.()
  }
  store.extractMode.enabled = next
}

function clearExtractSelection() {
  canvasPreviewRef.value?.clearExtractSelection?.()
}

function applyExtract() {
  const preview = canvasPreviewRef.value
  if (!preview || typeof preview.applyExtractSelection !== 'function') return
  const result = preview.applyExtractSelection()
  if (!result) {
    alert('请先绘制提取选区')
    return
  }
  if ('error' in result) {
    alert(result.error)
    return
  }
  const fgImg = new Image()
  fgImg.onload = () => {
    const extractedCount = store.layers.filter(l => l.id?.startsWith('extracted_')).length
    store.addLayer({
      id: `extracted_${Date.now()}`,
      name: `Extract ${extractedCount + 1}`,
      type: 'foreground',
      image_data: result.foregroundDataUrl,
      img: fgImg,
      x: 0, y: 0, scale: 1, rotation: 0, opacity: 1, mask_size: 0, keyframes: {}
    })
  }
  fgImg.src = result.foregroundDataUrl
  const bgLayer = store.layers.find(l => l.type === 'background')
  if (bgLayer && result.backgroundDataUrl) {
    const bgImg = new Image()
    bgImg.onload = () => {
        bgLayer.image_data = result.backgroundDataUrl
        bgLayer.img = bgImg
        store.updateLayer(store.layers.indexOf(bgLayer), { image_data: result.backgroundDataUrl })
    }
    bgImg.src = result.backgroundDataUrl
  }
  store.extractMode.enabled = false
  canvasPreviewRef.value?.clearExtractSelection?.()
}

function addForeground() {
  pendingType = 'foreground'
  fileInput.value?.click()
}

function addBackground() {
  pendingType = 'background'
  fileInput.value?.click()
}

function onFile(e: Event) {
  const files = (e.target as HTMLInputElement).files
  if (!files) return
  Array.from(files).forEach((file, i) => {
    const reader = new FileReader()
    reader.onload = (ev) => {
      const data = ev.target?.result as string
      const img = new Image()
      img.onload = () => {
        store.addLayer({
          id: 'uploaded_' + Date.now() + '_' + i,
          name: file.name.replace(/\.[^/.]+$/, ''),
          type: pendingType,
          image_data: data,
          img,
          x: 0, y: 0, scale: 1, rotation: 0, opacity: 1, mask_size: 0, keyframes: {}, bg_mode: 'fit'
        })
      }
      img.src = data
    }
    reader.readAsDataURL(file)
  })
  if (fileInput.value) fileInput.value.value = ''
}

function moveUp() { moveLayer(-1) }
function moveDown() { moveLayer(1) }

function moveLayer(d: number) {
  const i = store.currentLayerIndex
  if (i < 0) return
  const n = i + d
  if (n >= 0 && n < store.layers.length) {
    const l = store.layers[i]
    store.layers.splice(i, 1)
    store.layers.splice(n, 0, l)
    store.selectLayer(n)
  }
}

onBeforeUnmount(() => {
  if (resizeObserver && timelineRef.value) {
    resizeObserver.disconnect()
    resizeObserver = null
  }
  window.removeEventListener('resize', syncTimelineWidth)
  save()
})
</script>
